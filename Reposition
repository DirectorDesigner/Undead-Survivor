using UnityEngine;

public class Reposition : MonoBehaviour
{

    Collider2D coll;

    private void Awake()
    {
        coll = GetComponent<Collider2D>(); // 초기화 용
    }


    private void OnTriggerExit2D(Collider2D collision)
    {
        if (!collision.CompareTag("Area")) // ! = 아니면이란 뜻
            return;                        // return은 더이상 실행하지 않고 함수 탈출
                                           // Area 태그가 붙은 애랑 부딪혀서 벗어났을 때만 아래 코드가 동작해라

                                                                            
        Vector3 playerPos = GameManager.instance.player.transform.position; // 거리를 구하기 위해 플레이어 위치와 타일맵 위치 미리 저장
        Vector3 MyPos = transform.position;                                 // 플레이어의 포지션
                                                                            // 타일맵의 트랜스폼 포지션



        // 오류 방지를 위해 미사용 - Vector3 playerDir = GameManager.instance.player.inputVec; // 플레이어가 어느 방향으로 이동 중인지 판단




        
        switch (transform.tag) // 맵 타일이 계속 이동 시키는 내용
                               // switch는 값에 따라 다른 동작 실행/로직을 나눠주는 키워드
        {
            case "Ground": // 케바케 할 때 그 케이스처럼

                float diffX = playerPos.x - MyPos.x; // 플레이어 위치 - 타일맵 위치 계산으로 거리 구하기
                float diffY = playerPos.y - MyPos.y; // 음수도 양수로 만들어주는 절대값 함수
                                                                // 결국 거리는 음수여도 -5(음수)여도 5만큼 움직인거니까
                                                                // 방향 상관없이 얼마나 떨어져있는지 확인하는 것임

                float dirX = diffX < 0 ? -1 : 1;          // ? = 3항 연산자 = (조건) ? (참일 때 값) : (거짓일 때 값)
                float dirY = diffY < 0 ? -1 : 1;
                                                                // 대각선일 때는 노멀라이즈드에 의해 1보다 작은 값이 되어버림(0.7이 됨)
                                                                // 그래서 0보다 작으면 -1로, 아니면 1로 준다라는 뜻
                                                                // 노멀라이즈드가 없으면 적을 필요 없음
                diffX = Mathf.Abs(diffX);
                diffY = Mathf.Abs(diffY);  


                if (diffX > diffY)
                {
                    transform.Translate(Vector3.right * dirX * 40); // Translate = 지정된 값 만큼 현재 위치에서 이동
                                                                    // right만 있는 이유는 dirX를 곱해주니까 left를 안써도 같은 효과를 일으킴
                                                                    // 오른쪽 가면 Vector3.right * (+1) * 40 → 오른쪽으로 40
                                                                    // 왼쪽 가면 Vector3.right * (-1) * 40 → 왼쪽으로 40
                }
                else if (diffX < diffY)
                {
                    transform.Translate(Vector3.up * dirY * 40);
                }
                    break;
            
            case "Enemy": // 적을 계속 이동 시키는 내용
                if (coll.enabled)
                {
                    Vector3 dist = playerPos - MyPos;
                    Vector3 ran = new Vector3(Random.Range(-3, 3), Random.Range(-3, 3), 0);

                    transform.Translate(ran + dist * 2); // 플레이어 이동 방향의 맞은 편에서 나올 수 있도록
                }
                break;
        }

    }

}
